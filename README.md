# OS-Challenge
## 👋 운영
- 스터디 주제: 운영체제
- 총 인원 수: 4명
- 운영 기간: 23.04.20 ~ 23.05.18 ( 5주: 4주 발표 + [1주 모의 면접](https://github.com/CS-Challenge/OS-Challenge/wiki/%EB%A9%B4%EC%A0%91-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A7%84%ED%96%89-%EB%B0%A9%EC%8B%9D) )
- 모임 날짜: 매주 목요일 오후 7시 (2시간 ~ 3시간), 온라인
- 보증금: 3만원 (스터디 종료 후 벌금 제외한 보증금 모두 반환)

<br>

## 📍규칙
[Wiki 페이지](https://github.com/CS-Challenge/OS-Challenge/wiki/%EC%8A%A4%ED%84%B0%EB%94%94-%EA%B7%9C%EC%B9%99) 참고

<br>

## 👩🏻‍💻 스터디원
<table>
    <tr>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/yujung7768903" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/seoeunbae" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/suhyunsim" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/MoonDD99" width="140px" /></td>
    </tr>
    <tr>
        <td align="center">
          <a href="https://github.com/yujung7768903"> 김유정 </a>
        </td>
        <td align="center">
          <a href="https://github.com/seoeunbae"> 배서은 </a>
        </td>
        <td align="center">
          <a href="https://github.com/suhyunsim"> 심수현 </a>
        </td>
        <td align="center">
          <a href="https://github.com/MoonDD99"> 문정현 </a>
        </td>
    </tr>
</table>
<!--
| 이름   | GitHub                                       |
| ------ | -------------------------------------------- |
| 김유정 | [@yujung7768903](https://github.com/yujung7768903) |
| 배서은 | [@seoeunbae](https://github.com/seoeunbae) |
| 심수현 | [@suhyunsim](https://github.com/suhyunsim) |
| 문정현 | [@MoonDD99](https://github.com/MoonDD99) |
-->

<br>

## 📚 학습 주제
<!-- 예시
* [주제이름](링크)
-->
### 1주차
* [프로세스와 스레드의 차이](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90)
* [Thread Safety](https://github.com/CS-Challenge/OS-Challenge/tree/main/Thread-safety)

### 2주차
* [프로세스 스케줄링](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
* [페이지와 세그먼트](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80%20%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8)

### 3주차
* [프로세스 동기화](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94)
* [자바와 스프링에서 동기화 적용 방법](https://github.com/CS-Challenge/OS-Challenge/tree/main/%EC%9E%90%EB%B0%94%EC%99%80%20%EC%8A%A4%ED%94%84%EB%A7%81%EC%97%90%EC%84%9C%20%EB%8F%99%EA%B8%B0%ED%99%94%20%EC%A0%81%EC%9A%A9%20%EB%B0%A9%EB%B2%95)

### 4주차
* [RAM과 캐시메모리](https://github.com/CS-Challenge/OS-Challenge/blob/main/RAM%EA%B3%BC%20%EC%BA%90%EC%8B%9C/RAM%EA%B3%BC%20%EC%BA%90%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%8B%AC%EC%88%98%ED%98%84.pdf)
* [유저레벨스레드와 커널레벨스레드](https://github.com/CS-Challenge/OS-Challenge/blob/main/%EC%9C%A0%EC%A0%80%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80%20%EC%BB%A4%EB%84%90%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EB%A0%88%EB%93%9C/%EA%B9%80%EC%9C%A0%EC%A0%95_%EC%9C%A0%EC%A0%80%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_%EC%BB%A4%EB%84%90%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C.pdf)
* [페이지교체와 프레임할당](https://github.com/CS-Challenge/OS-Challenge/blob/main/%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4%EC%99%80%20%ED%94%84%EB%A0%88%EC%9E%84%ED%95%A0%EB%8B%B9_%EB%B0%B0%EC%84%9C%EC%9D%80.pdf)
* [다중처리기 스케줄링](https://github.com/CS-Challenge/OS-Challenge/blob/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/%EB%AC%B8%EC%A0%95%ED%98%84_%EB%8B%A4%EC%A4%91_%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.pdf)

<br>

## ⁉️ 퀴즈 총정리
<!-- <details>
<summary>정답</summary>
</details> -->
### [ 프로세스 스케줄링 ]
#### Q1. 프로세서 스케줄링을 평가하는 기준으로 가장 거리가 먼 것은?
1️. 처리량  2️. 대기 시간  3️. 균형있는 자원 이용  4️. 오류 복구 시간
<details>
<summary>정답</summary>
**4️. 오류 복구 시간**
</details>

#### Q2. 다음과 같이 작업을 제출했다. 이를 SJF 정책을 사용하여 스케줄링하면 작업 번호 3의 완료 시간은?
<img width="241" alt="image" src="https://github.com/CS-Challenge/OS-Challenge/assets/68562176/63db7aa2-6a11-4821-8922-38900e8e3074">
1️. 13:25  2️. 12:25  3️. 12:00  4️. 14:00
<details>
<summary>정답</summary>
**2️. 12:25**       
    
* SJF 스케줄링 알고리즘은 Short Job First의 약자로 남은 작업 중 가장 작업 시간이 짧은 작업에게 자원을 할당해주는 방식이다.
<img width="542" alt="Screenshot 2023-05-15 at 12 50 25 AM" src="https://github.com/CS-Challenge/OS-Challenge/assets/68562176/dcbbc8c1-6017-4c00-9111-e4abf93643cb">
</details>

#### Q3. RR(Round-Robin) 스케줄링에 대한 설명으로 옳지 않은 것은?
1️. 시간 할당량을 크게 하면 입출력 위주의 작업이나 긴급을 요하는 작업에 신속히 반응하지 못한다.    
2️. 시간 할당량이 작으면 FCFS 스케줄링과 같아진다.    
3️. 시분할 시스템(time sharing system)을 위해 고안된 방법이다.    
4️. 시간 할당량이 작을수록 문맥 교환 및 오버헤드가 자주 발생한다. 
<details>
<summary>정답</summary>
**2️. 시간 할당량이 작으면 FCFS 스케줄링과 같아진다.**    

* 시간 할당량(타임 슬라이스)가 커지면 FCFS 스케줄링과 같아지고, 작아지면 문맥교환이 자주 발생하여 오버헤드가 증가한다.
* 따라서 적절하게 시간 할당량을 정하는 것이 중요하지만 절대적으로 좋은 값을 찾는 것은 어렵다.
</details>

#### Q4. Multiprogramming / Timesharing은 각각 어떤 프로그램에 적합할까 ?
<details>
<summary>정답</summary>
    
**Multiprogramming : batch processing, background processing과 같이 사용자에게 보여지지 않은 프로그램에 적합하다.**

* timesharing보다 overhead가 적다
* 처리율(시간동안 처리되는 작업의 수)이 좋고 낭비되는 시간이 적다.
* 하지만 응답시간(프로그램 실행 명령 ~ 실제로 실행되는 시간)은 Timesharing에 비해 크다.

**Timesharing : interactive processing, foreground processing과 같이 사용자에게 보여지는 프로그램에 적합하다**
* Multiprograing보다 overhead가 크다
* 응답시간이 적다.
* 낭비되는 시간이 많아진다. (시간간격보다 처리시간이 짧아도 시간간격만큼 해당 프로그램이 CPU 제어권을 가지고 있기 때문)
</details>

#### Q5. CPU 스케줄러는 어디에 위치할까?
<details>
<summary>정답</summary>
    
* CPU 스케줄러는 운영체제의 커널 내부에 위치합니다.
* 커널은 운영체제의 핵심 부분으로, 시스템 자원 관리, 입출력 처리, 파일 시스템 등 다양한 기능을 담당합니다.
* CPU 스케줄러는 이 중에서도 CPU 자원 관리를 담당하며, 프로세스 실행 우선순위에 따라 CPU 자원을 할당하는 역할을 수행합니다.
</details>

#### Q6. 문맥교환의 종류는 무엇이 있을까?
<details>
<summary>정답</summary>
    
* 자발적 문맥 교환 : 현재 사용 불가능한 자원을 요청했을 때 프로세스가 CPU 제어를 포기한 경우 발생
* 복귀 문맥 교환 : 인터렙트나 예외 상황이 발생하여 프로세스가 CPU를 반환한 후, 이전에 실행되던 프로세스로 돌아가기 위한 문맥 교환이며, 대개 운영체제의 커널 모드에서 실행된다.
* 비자발적 문맥 교환 : 타임 슬라이스가 만료되었거나 우선순위가 높은 프로세스에 의해 선점되는 경우와 같이 CPU를 빼앗겼을 때 발생한다.
</details>

<br>

---

<br>

### [ Thread Safety ]
#### Q1. Thread-Safe와 Race Condition의 관계에 대해 설명해주세요.

<details>
<summary>정답</summary>

* Thread-safe(스레드 안전): 멀티 스레드 프로그래밍에서, 변수나 객체, 함수 등의 자원이 여러 스레드에 대해 동시에 접근되어도 정상적으로 프로그램이 동작하는 것
* Race Condition: 현재 작업이 제어할 수 없는 또 다른 작업과의 진행 순서, 즉, 타이밍에 따라 결과가 달라져 여러 결과를 만들어낼 수 있는 바람직하지 않은 상황, 두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태
* thread-safe하다고 해서 race condition으로부터 자유롭다는 뜻 X
* race condition의 발생에도 불구하고, 프로그래머가 의도한 결과가 나온다면 thread-safe한 코드라고 할 수 있음
    * ex) 이 코드는 여러 스레드에 의해서 동시에 수행되어도 문제 없다! → thread safe한 코드
</details>

#### Q2. Thread-Safety하게 구현하는 방법 한 가지를 설명해주세요.

<details>
<summary>정답</summary>

* Reentrency 재진입성
* Thread-Local Storage 스레드 지역 저장소
* Atomic Operation 원자 연산
* Mutual Exclusion Locks 락
* Immutable Object 불변 객체
* Producer - Consumer Pattern
* Blocking Queue
* Volatile
* Instance Confinement 인스턴스 한정
* Thread Confinement 스레드 한정
* Condition Queues 조건 큐
* Synchronized Collections 동기화 컬렉션
* State Dependence 상태범위 제한
</details>

#### Q3. synchronized 한정자가 보이는 메서드는 항상 thread-safe 할까요?


<details>
<summary>정답</summary>

* X
    * 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다. 따라서 이것만으로는 그 메서드가 스레드 안전하다고 믿기 어렵다.

</details>

<br>

---

<br>

### [ 페이지와 세그먼트 ]
#### Q1. TLB는 어떤 문제를 해결하기 위해 등장했을까요?

<details>
<summary>정답</summary>
* 페이지 테이블을 메모리에 두면 메모리에 있는 페이지 테이블을 보기 위해, 그리고 프레임에 접근하기 위해 두 번이나 메모리 접근이 필요하기 때문에 TLB 라는 캐시 메모리를 사용합니다.

</details>

#### Q2. 다음 페이지 엔트리에 대한 설명 중 틀린 것은 무엇일까요?

<img width="500" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/b328d3c3-1d4f-44ee-8935-11d2a2cb9778">

1. 1번 페이지는 수정된 적이 있습니다.
2. 1번 페이지는 메모리에 적재되어 있지 않습니다.
3. 2번 페이지는 읽기만 가능합니다.
4. CPU에 의해 참조된 페이지가 없습니다.

<details>
<summary>정답</summary>

<img width="600" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/4ea3fbb2-ffe8-4eb2-9b5f-ebc03560cbcc">

</details>

#### Q3. 페이지 폴트란 무엇이고 이를 다루기 위한 방법은 무엇일까요?

<details>
<summary>정답</summary>

* 프로세스가 실행되는 도중에 필요한 페이지가 물리 메모리에 존재하지 않아 디스크에서 해당 페이지를 가져와야 하는 경우를 말합니다. 즉, 프로세스가 접근하려는 페이지가 물리적 메모리에 존재하지 않는 상태에서 발생하는 인터럽트입니다. 페이지 폴트가 발생하면 운영체제는 해당 페이지를 물리 메모리에 적재하여 프로세스가 접근할 수 있도록 해야 합니다. 
* 이때, 메모리에 빈 공간이 있다면 페이지 폴트를 처리하기 위해 디스크에서 해당 페이지를 읽어와 물리 메모리에 적재합니다. 그러나 빈 공간이 없는 경우, 운영체제는 페이지 교체(Page Replacement) 알고리즘을 사용하여 더 이상 사용되지 않는 페이지를 디스크로 내보내고, 새로운 페이지를 메모리에 적재합니다.

</details>

<br>

---

<br>

### [ 자바와 스프링에서 동기화 적용 방법 ]
#### Q1. 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?

<details>
<summary>정답</summary>
    
* i++이 3개의 instruction(READ-MODITY-WRITE)로 구성되어있기 때문입니다. 멀티 스레드 프로그래밍에서는 스레드 하나가 값을 읽어 i+1을 하기 직전에 다른 스레드가 i를 읽어 i+1을 수행하고 반영하는 동작을 수행한다면 후자의 연산은 무효가 되는 현상이 발생합니다. 

</details>

#### Q2. Java에서 동시성과 관련된 예약어를 말씀해주세요. (가시성, 원자성의 개념을 포함해서!)

<details>
<summary>정답</summary>
    
* volatile: 가시성 보장 / synchronized: 가시성, 원자성 보장 / Atomic: non-blocking, 가시성, 원자성 보장

</details>

#### Q3. ThreadLocal을 사용할 때의 주의점은 무엇일까요?


<details>
<summary>정답</summary>

* 쓰레드 로컬은 메모리 누수의 주범이 됨으로 주의해서 사용해야 합니다. Thread pool 환경에서 ThreadLocal을 사용하는 경우 변수에 보관된 데이터 사용이 끝나면 반드시 해당 데이터를 삭제해야 하고 그렇지 않을 경우 재사용 되는 쓰레드가 올바르지 않은 데이터를 참조할 수도 있습니다.

</details>


<br>

---

<br>

### [ RAM과 캐시메모리 ]
#### Q1. 각각 어떤 RAM을 설명한 것인지 맞춰보세요. (DRAM, SRAM, SDRAM, DDR SDRAM)
1) 대역폭을 2배 넓힌 SDRAM:
2) 시간이 지나도 저장된 데이터가 사라지지 않는 RAM:
3) 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화해야 하는 RAM:
4) 클럭과 동기화된 DRAM:
5) 주로 캐시 메모리로 활용:
6) 주로 주기억장치로 활용:
7) 대용량화하기 유리:
8) 집적도가 상대적으로 낮음:


<details>
<summary>정답</summary>
    
1) 대역폭을 2배 넓힌 SDRAM: DDR SDRAM
2) 시간이 지나도 저장된 데이터가 사라지지 않는 RAM: SRAM
3) 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화해야 하는 RAM: DRAM
4) 클럭과 동기화된 DRAM: SDRAM
5) 주로 캐시 메모리로 활용: SRAM
6) 주로 주기억장치로 활용: DRAM
7) 대용량화하기 유리: DRAM
8) 집적도가 상대적으로 낮음: SRAM

</details>

#### Q2. 캐시 메모리를 사용하는 이유는 무엇인가요?


<details>
<summary>정답</summary>

* CPU가 메모리에 접근하는 시간이 CPU의 연산 속도보다 느리기 때문에 이러한 병목 지점의 처리 시간 차이를 메우기 위해 사용
</details>

#### Q3. 저장 장치 계층 구조를 완성해보세요. (메모리, 보조기억장치, 캐시 메모리, 레지스터)

<details>
<summary>정답</summary>
<img width="300" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/c1c1ddb2-f134-409d-987d-bf433261eb9c">

</details>


<br>

---

<br>


### [ 유저레벨스레드와 커널레벨스레드 ]
#### Q1. 스레드 모델에 해당하지 않는 모델은?
  1️. 1:1 model  2️. 1:M model  3️. N:M model  4️. 3-level model
<details>
<summary>정답</summary>
**4️. 3-level model**
</details>

#### Q2. 유저 레벨의 스레드와 커널 레벨의 스레드 중간에 있는 계층으로 둘의 통신을 돕는 개체는 무엇인가요?
<details>
<summary>정답</summary>
** Light Weight Process(LWP)**
    
* 다대다 모델이나 two-level 모델에서 프로세스에 할당된 적절한 수의 커널 스레드를 유지하기 위해서 커널과 유저 레벨 스레드의 매니저와 통신할 수 있는 방법이 필요하다. 이 때 커널 스레 드와 유저 스레드의 징검다리 역할을 하는 계층이다.
* 해당 계층이 없는 모델에서 “Light Weight Process”는 일반적으로 커널 스레드를  의미하고, “Thread”는 유저 스레드를 의미한다.
</details>

#### Q3. 리눅스에서 스케줄링 대상은 무엇일까요?
1️. 프로세스  2️. 스레드  3️. 커널 레벨 스레드  4️. 모두 가능
<details>
<summary>정답</summary>
**4️. 모두 가능**
</details>


---

<br>


### [ JAVA의 동기화 처리 방법 ]
#### Q1. race condition 방지를 위해 보장되어야 하는 두 가지 속성은?

<details>
<summary>정답</summary>

**원자성과 가시성**

</details>

#### Q2. synchronized 키워드 사용시에 주의할 점 2가지는?
<details>
<summary>정답</summary>

**대기 스레드로 인한 성능저하, 데드락 / 싱크로나이즈드 블록 내에서 참조객체를 수정하는 것, 메소드전체가 아닌, 객체레벌로 지정한다.**

</details>

#### Q3. atmoicReference 는 어떤 방식의 **_1) 동기화_**인지 그리고 내부에서 사용되는 두가지 **_2) 메커니즘_**은?

<details>
<summary>정답</summary>

**1. 논블로킹 방식 2. CAS알고리즘과 volatile키워드**

</details>

