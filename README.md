# OS-Challenge
## 👋 운영
- 스터디 주제: 운영체제
- 총 인원 수: 4명
- 운영 기간: 23.04.20 ~ 23.05.18 ( 5주: 4주 발표 + [1주 모의 면접](https://github.com/CS-Challenge/OS-Challenge/wiki/%EB%A9%B4%EC%A0%91-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A7%84%ED%96%89-%EB%B0%A9%EC%8B%9D) )
- 모임 날짜: 매주 목요일 오후 7시 (2시간 ~ 3시간), 온라인
- 보증금: 3만원 (스터디 종료 후 벌금 제외한 보증금 모두 반환)

## 📍규칙
[Wiki 페이지](https://github.com/CS-Challenge/OS-Challenge/wiki/%EC%8A%A4%ED%84%B0%EB%94%94-%EA%B7%9C%EC%B9%99) 참고

## 👩🏻‍💻 스터디원
<table>
    <tr>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/yujung7768903" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/seoeunbae" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/suhyunsim" width="140px" /></td>
        <td height="140px" align="center"><img src="https://avatars.githubusercontent.com/MoonDD99" width="140px" /></td>
    </tr>
    <tr>
        <td align="center">
          <a href="https://github.com/yujung7768903"> 김유정 </a>
        </td>
        <td align="center">
          <a href="https://github.com/seoeunbae"> 배서은 </a>
        </td>
        <td align="center">
          <a href="https://github.com/suhyunsim"> 심수현 </a>
        </td>
        <td align="center">
          <a href="https://github.com/MoonDD99"> 문정현 </a>
        </td>
    </tr>
</table>
<!--
| 이름   | GitHub                                       |
| ------ | -------------------------------------------- |
| 김유정 | [@yujung7768903](https://github.com/yujung7768903) |
| 배서은 | [@seoeunbae](https://github.com/seoeunbae) |
| 심수현 | [@suhyunsim](https://github.com/suhyunsim) |
| 문정현 | [@MoonDD99](https://github.com/MoonDD99) |
-->

## 📚 학습 주제
<!-- 예시
* [주제이름](링크)
-->
### 1주차
* [프로세스와 스레드의 차이](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90)
* [Thread Safety](https://github.com/CS-Challenge/OS-Challenge/tree/main/Thread-safety)

### 2주차
* [프로세스 스케줄링](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)
* [페이지와 세그먼트](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80%20%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8)

### 3주차
* [프로세스 동기화](https://github.com/CS-Challenge/OS-Challenge/tree/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94)
* [자바와 스프링에서 동기화 적용 방법](https://github.com/CS-Challenge/OS-Challenge/tree/main/%EC%9E%90%EB%B0%94%EC%99%80%20%EC%8A%A4%ED%94%84%EB%A7%81%EC%97%90%EC%84%9C%20%EB%8F%99%EA%B8%B0%ED%99%94%20%EC%A0%81%EC%9A%A9%20%EB%B0%A9%EB%B2%95)

### 4주차
* [RAM과 캐시메모리](https://github.com/CS-Challenge/OS-Challenge/blob/main/RAM%EA%B3%BC%20%EC%BA%90%EC%8B%9C/RAM%EA%B3%BC%20%EC%BA%90%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%8B%AC%EC%88%98%ED%98%84.pdf)
* [유저레벨스레드와 커널레벨스레드](https://github.com/CS-Challenge/OS-Challenge/blob/main/%EC%9C%A0%EC%A0%80%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80%20%EC%BB%A4%EB%84%90%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EB%A0%88%EB%93%9C/%EA%B9%80%EC%9C%A0%EC%A0%95_%EC%9C%A0%EC%A0%80%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_%EC%BB%A4%EB%84%90%EB%A0%88%EB%B2%A8%EC%8A%A4%EB%A0%88%EB%93%9C.pdf)
* [페이지교체와 프레임할당](https://github.com/CS-Challenge/OS-Challenge/blob/main/%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4%EC%99%80%20%ED%94%84%EB%A0%88%EC%9E%84%ED%95%A0%EB%8B%B9_%EB%B0%B0%EC%84%9C%EC%9D%80.pdf)
* [다중처리기 스케줄링](https://github.com/CS-Challenge/OS-Challenge/blob/main/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/%EB%AC%B8%EC%A0%95%ED%98%84_%EB%8B%A4%EC%A4%91_%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81.pdf)

## ⁉️ 퀴즈 총정리
<!-- <details>
<summary>정답</summary>
</details> -->
### [ 프로세스 스케줄링 ]
#### Q1. 프로세서 스케줄링을 평가하는 기준으로 가장 거리가 먼 것은?
1️. 처리량  2️. 대기 시간  3️. 균형있는 자원 이용  4️. 오류 복구 시간
<details>
<summary>정답</summary>
**4️. 오류 복구 시간**
</details>

#### Q2. 다음과 같이 작업을 제출했다. 이를 SJF 정책을 사용하여 스케줄링하면 작업 번호 3의 완료 시간은?
<img width="241" alt="image" src="https://github.com/CS-Challenge/OS-Challenge/assets/68562176/63db7aa2-6a11-4821-8922-38900e8e3074">
1️. 13:25  2️. 12:25  3️. 12:00  4️. 14:00
<details>
<summary>정답</summary>
**2️. 12:25**       
    
* SJF 스케줄링 알고리즘은 Short Job First의 약자로 남은 작업 중 가장 작업 시간이 짧은 작업에게 자원을 할당해주는 방식이다.
<img width="542" alt="Screenshot 2023-05-15 at 12 50 25 AM" src="https://github.com/CS-Challenge/OS-Challenge/assets/68562176/dcbbc8c1-6017-4c00-9111-e4abf93643cb">
</details>

#### Q3. RR(Round-Robin) 스케줄링에 대한 설명으로 옳지 않은 것은?
1️. 시간 할당량을 크게 하면 입출력 위주의 작업이나 긴급을 요하는 작업에 신속히 반응하지 못한다.    
2️. 시간 할당량이 작으면 FCFS 스케줄링과 같아진다.    
3️. 시분할 시스템(time sharing system)을 위해 고안된 방법이다.    
4️. 시간 할당량이 작을수록 문맥 교환 및 오버헤드가 자주 발생한다. 
<details>
<summary>정답</summary>
**2️. 시간 할당량이 작으면 FCFS 스케줄링과 같아진다.**    

* 시간 할당량(타임 슬라이스)가 커지면 FCFS 스케줄링과 같아지고, 작아지면 문맥교환이 자주 발생하여 오버헤드가 증가한다.
* 따라서 적절하게 시간 할당량을 정하는 것이 중요하지만 절대적으로 좋은 값을 찾는 것은 어렵다.
</details>

#### Q4. Multiprogramming / Timesharing은 각각 어떤 프로그램에 적합할까 ?
<details>
<summary>정답</summary>
    
**Multiprogramming : batch processing, background processing과 같이 사용자에게 보여지지 않은 프로그램에 적합하다.**

* timesharing보다 overhead가 적다
* 처리율(시간동안 처리되는 작업의 수)이 좋고 낭비되는 시간이 적다.
* 하지만 응답시간(프로그램 실행 명령 ~ 실제로 실행되는 시간)은 Timesharing에 비해 크다.

**Timesharing : interactive processing, foreground processing과 같이 사용자에게 보여지는 프로그램에 적합하다**
* Multiprograing보다 overhead가 크다
* 응답시간이 적다.
* 낭비되는 시간이 많아진다. (시간간격보다 처리시간이 짧아도 시간간격만큼 해당 프로그램이 CPU 제어권을 가지고 있기 때문)
</details>

#### Q5. CPU 스케줄러는 어디에 위치할까?
<details>
<summary>정답</summary>
    
* CPU 스케줄러는 운영체제의 커널 내부에 위치합니다.
* 커널은 운영체제의 핵심 부분으로, 시스템 자원 관리, 입출력 처리, 파일 시스템 등 다양한 기능을 담당합니다.
* CPU 스케줄러는 이 중에서도 CPU 자원 관리를 담당하며, 프로세스 실행 우선순위에 따라 CPU 자원을 할당하는 역할을 수행합니다.
</details>

#### Q6. 문맥교환의 종류는 무엇이 있을까?
<details>
<summary>정답</summary>
    
* 자발적 문맥 교환 : 현재 사용 불가능한 자원을 요청했을 때 프로세스가 CPU 제어를 포기한 경우 발생
* 복귀 문맥 교환 : 인터렙트나 예외 상황이 발생하여 프로세스가 CPU를 반환한 후, 이전에 실행되던 프로세스로 돌아가기 위한 문맥 교환이며, 대개 운영체제의 커널 모드에서 실행된다.
* 비자발적 문맥 교환 : 타임 슬라이스가 만료되었거나 우선순위가 높은 프로세스에 의해 선점되는 경우와 같이 CPU를 빼앗겼을 때 발생한다.
</details>
    
### [ 유저레벨스레드와 커널레벨스레드 ]
#### Q1. 스레드 모델에 해당하지 않는 모델은?
  1️. 1:1 model  2️. 1:M model  3️. N:M model  4️. 3-level model
<details>
<summary>정답</summary>
**4️. 3-level model**
</details>

#### Q2. 유저 레벨의 스레드와 커널 레벨의 스레드 중간에 있는 계층으로 둘의 통신을 돕는 개체는 무엇인가요?
<details>
<summary>정답</summary>
** Light Weight Process(LWP)**
    
* 다대다 모델이나 two-level 모델에서 프로세스에 할당된 적절한 수의 커널 스레드를 유지하기 위해서 커널과 유저 레벨 스레드의 매니저와 통신할 수 있는 방법이 필요하다. 이 때 커널 스레 드와 유저 스레드의 징검다리 역할을 하는 계층이다.
* 해당 계층이 없는 모델에서 “Light Weight Process”는 일반적으로 커널 스레드를  의미하고, “Thread”는 유저 스레드를 의미한다.
</details>

#### Q3. 리눅스에서 스케줄링 대상은 무엇일까요?
1️. 프로세스  2️. 스레드  3️. 커널 레벨 스레드  4️. 모두 가능
<details>
<summary>정답</summary>
**4️. 모두 가능**
</details>
